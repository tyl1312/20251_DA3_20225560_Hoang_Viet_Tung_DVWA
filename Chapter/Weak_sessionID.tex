\subsection{Overview}
Session IDs are used to track and identify user sessions on websites or web applications. They are generated by the server and assigned to users upon login or when a session is initiated. A weak session ID refers to a session identifier that lacks sufficient randomness or unpredictability. This makes it easier for attackers to guess or manipulate session IDs to gain unauthorized access to user accounts or perform session hijacking attack.

\noindent \textbf{Objective}: Work out how the ID is generated and then infer the IDs of other system users.

\newpage
\subsection{Low level}
\begin{lstlisting}
<?php

$html = "";

if ($_SERVER['REQUEST_METHOD'] == "POST") {
    if (!isset ($_SESSION['last_session_id'])) {
        $_SESSION['last_session_id'] = 0;
    }
    $_SESSION['last_session_id']++;
    $cookie_value = $_SESSION['last_session_id'];
    setcookie("dvwaSession", $cookie_value);
}
?>
\end{lstlisting}
\noindent In low level, when a POST request is received, the application initializes \$\_SESSION['last\_session\_id'] if it does not exist, increments it by 1, and then assigns the updated value to the cookie named dvwaSession using setcookie(). As you can see, the cookie value is predictable meaning that the attacker can easily guess or brute force valid session values by incrementing or decrementing the number, allowing them to hijack other users' session.

\noindent \textbf{Patching:} The patching approach for this vulnerability is pretty straightforward: generate an unpredictable and random session ID. To achieve this, there are several methods available, such as using PHP built-in functions like random\_bytes() or openssl\_random\_pseudo\_bytes() to generate cryptographically secure random values. These random values can then be further encoded to create a session ID that is difficult to predict. Additionally, it is important to ensure that session IDs are of sufficient length, at least 16 bytes, to provide adequate defense against brute force attacks. By implementing these practices, the application can significantly enhance the security of session management and protect against session hijacking attacks.

\subsection{Medium level}
\begin{lstlisting}
<?php

$html = "";

if ($_SERVER['REQUEST_METHOD'] == "POST") {
    $cookie_value = time();
    setcookie("dvwaSession", $cookie_value);
}
?>
\end{lstlisting}
\noindent In medium level, whenever a POST request is received, the dvwaSession cookie value is set to the current Unix timestamp obtained time() function which returns the number of second since January 1st, 1970. This results in a weak session identifier because the value is highly predictable and can be easily guessed or brute forced by an attacker.
\noindent \textbf{Patching:} The patching approach is similar to the low level: generate a random and unpredictable session ID using cryptographically secure methods while avoid using predictable values such as timestamps, sequential numbers, or user-specific information. 

\subsection{High level}
\begin{lstlisting}
<?php

$html = "";

if ($_SERVER['REQUEST_METHOD'] == "POST") {
    if (!isset ($_SESSION['last_session_id_high'])) {
        $_SESSION['last_session_id_high'] = 0;
    }
    $_SESSION['last_session_id_high']++;
    $cookie_value = md5($_SESSION['last_session_id_high']);
    setcookie("dvwaSession", $cookie_value, time()+3600, "/vulnerabilities/weak_id/", $_SERVER['HTTP_HOST'], false, false);
}
?>
\end{lstlisting}
\noindent The high level code generates a value based on a server-side counter and stores it in a cookie named dvwaSession. When a POST request is received, the application initializes \$\_SESSION['last\_session\_id\_high'] if it does not already exist, increments it by one, and then applies the MD5 hash to the counter value before setting it as the cookie value. The cookie is configured with a one-hour expiration time and scoped to a specific path.

\noindent Although hashing is introduced, this session ID is still weak. The original value is a simple, predictable counter that increases sequentially, and MD5 hashing does not add meaningful security because MD5 is a fast, deterministic hash that is easy to break.

\noindent \textbf{Patching:} The patching approach remains unchanged for high level.Additionally, avoid using fast, outdated hashing algorithms like MD5 for security purposes. 